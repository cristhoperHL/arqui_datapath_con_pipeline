$date
	Mon Nov 18 01:36:29 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module test $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 # writedata [31:0] $end
$var wire 1 $ zero_to_mux $end
$var wire 1 % zero $end
$var wire 5 & writereg [4:0] $end
$var wire 32 ' sign_extended [31:0] $end
$var wire 32 ( shift_left_branch [31:0] $end
$var wire 32 ) read_data2 [31:0] $end
$var wire 32 * read_data1 [31:0] $end
$var wire 32 + nuevo [31:0] $end
$var wire 32 , mux_branch_out [31:0] $end
$var wire 32 - mux_alu [31:0] $end
$var wire 32 . branch_pc [31:0] $end
$var wire 4 / alucontrol [3:0] $end
$var wire 32 0 alu_result [31:0] $end
$var wire 32 1 address_final [31:0] $end
$var wire 1 2 RegWrite $end
$var wire 1 3 RegDst $end
$var wire 32 4 Out_PC [31:0] $end
$var wire 1 5 MemtoReg $end
$var wire 2 6 MemWrite [1:0] $end
$var wire 2 7 MemRead [1:0] $end
$var wire 32 8 Jump_address [31:0] $end
$var wire 1 9 Jump $end
$var wire 32 : Instruction [31:0] $end
$var wire 32 ; DM_out [31:0] $end
$var wire 32 < DM_mux [31:0] $end
$var wire 1 = Branch $end
$var wire 1 > ALUsrc $end
$var wire 4 ? ALUOP [3:0] $end
$scope module call_ALU $end
$var wire 32 @ entr2 [31:0] $end
$var wire 32 A entr1 [31:0] $end
$var wire 4 B alu_ctrl [3:0] $end
$var reg 32 C alu_result [31:0] $end
$var reg 1 % zero $end
$upscope $end
$scope module call_Control $end
$var wire 6 D Instruction [5:0] $end
$var wire 1 ! clk $end
$var reg 4 E ALUOp [3:0] $end
$var reg 1 > ALUSrc $end
$var reg 1 = Branch $end
$var reg 1 9 Jump $end
$var reg 2 F MemRead [1:0] $end
$var reg 2 G MemWrite [1:0] $end
$var reg 1 5 MemtoReg $end
$var reg 1 3 RegDst $end
$var reg 1 2 RegWrite $end
$upscope $end
$scope module call_IM $end
$var wire 32 H pc [31:0] $end
$var reg 32 I out [31:0] $end
$upscope $end
$scope module call_RF $end
$var wire 1 ! clk $end
$var wire 5 J readreg1 [4:0] $end
$var wire 5 K readreg2 [4:0] $end
$var wire 1 2 regwrite $end
$var wire 32 L writedata [31:0] $end
$var wire 5 M writereg [4:0] $end
$var reg 32 N read_data1 [31:0] $end
$var reg 32 O read_data2 [31:0] $end
$upscope $end
$scope module call_Signextend $end
$var wire 16 P a [15:0] $end
$var reg 32 Q b [31:0] $end
$upscope $end
$scope module call_adder $end
$var wire 32 R y [31:0] $end
$var wire 32 S b [31:0] $end
$var wire 32 T a [31:0] $end
$upscope $end
$scope module call_adder_pc $end
$var wire 32 U pc [31:0] $end
$var reg 32 V pc_add [31:0] $end
$upscope $end
$scope module call_alu_control $end
$var wire 4 W aluOp [3:0] $end
$var wire 6 X func [5:0] $end
$var reg 4 Y out [3:0] $end
$upscope $end
$scope module call_and $end
$var wire 1 = a $end
$var wire 1 % b $end
$var wire 1 $ out $end
$upscope $end
$scope module call_data_memory $end
$var wire 32 Z address [31:0] $end
$var wire 1 ! clk $end
$var wire 2 [ memread [1:0] $end
$var wire 2 \ memwrite [1:0] $end
$var wire 32 ] writedata [31:0] $end
$var reg 32 ^ read_data [31:0] $end
$upscope $end
$scope module call_mux2_1_5bits $end
$var wire 5 _ a [4:0] $end
$var wire 5 ` b [4:0] $end
$var wire 1 3 sel $end
$var wire 5 a out [4:0] $end
$upscope $end
$scope module call_mux2_1_branch $end
$var wire 32 b a [31:0] $end
$var wire 32 c b [31:0] $end
$var wire 1 $ sel $end
$var wire 32 d out [31:0] $end
$upscope $end
$scope module call_mux2_1_jump $end
$var wire 32 e b [31:0] $end
$var wire 1 9 sel $end
$var wire 32 f out [31:0] $end
$var wire 32 g a [31:0] $end
$upscope $end
$scope module call_mux_data_memory $end
$var wire 32 h a [31:0] $end
$var wire 32 i b [31:0] $end
$var wire 1 5 sel $end
$var wire 32 j out [31:0] $end
$upscope $end
$scope module call_pc $end
$var wire 1 ! clk $end
$var wire 32 k d [31:0] $end
$var wire 1 " reset $end
$var reg 32 l q [31:0] $end
$upscope $end
$scope module call_shift_branch $end
$var wire 32 m imm [31:0] $end
$var reg 32 n branch_address [31:0] $end
$upscope $end
$scope module call_shift_jump $end
$var wire 4 o PC [3:0] $end
$var wire 26 p imm [25:0] $end
$var reg 32 q jump [31:0] $end
$var reg 2 r shift [1:0] $end
$upscope $end
$scope module mux_antes_del_alu $end
$var wire 32 s a [31:0] $end
$var wire 32 t b [31:0] $end
$var wire 1 > sel $end
$var wire 32 u out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1 u
bx t
b1 s
b0 r
b1000010000000000000000000100 q
b10000100000000000000000001 p
b0 o
b100 n
b1 m
b0 l
b100 k
bx j
bx i
bx h
b1000010000000000000000000100 g
b1000 f
b1000 e
b1000 d
b1000 c
b100 b
b0 a
b0 `
b10000 _
bx ^
bx ]
b0 \
b0 [
bx Z
b0 Y
b1 X
b100 W
b100 V
b0 U
b100 T
b100 S
b1000 R
b1 Q
b1 P
bx O
bx N
b0 M
bz L
b10000 K
b10000 J
b100010000100000000000000000001 I
b0 H
b0 G
b0 F
b100 E
b1000 D
bx C
b0 B
bx A
b1 @
b100 ?
1>
0=
bx <
bx ;
b100010000100000000000000000001 :
09
b1000010000000000000000000100 8
b0 7
b0 6
05
b0 4
03
12
b100 1
bx 0
b0 /
b1000 .
b1 -
b1000 ,
b1000 +
bx *
bx )
b100 (
b1 '
b0 &
0%
0$
bz #
1"
1!
$end
#1
0"
0!
#2
b1100 +
b1100 f
b1100 ,
b1100 d
b1100 e
b1100 .
b1100 R
b1100 c
b1000 1
b1000 T
b1000 V
b1000 b
b1000 k
b1 <
b1 j
b1 0
b1 C
b1 Z
b1 i
b0 )
b0 O
b0 ]
b0 t
b0 *
b0 A
b0 N
b100 4
b100 H
b100 U
b100 l
1!
#3
0!
#4
b1000 (
b1000 S
b1000 n
b10 <
b10 j
b10 0
b10 C
b10 Z
b10 i
b10 -
b10 @
b10 u
b1000110001000000000000001000 8
b1000110001000000000000001000 g
b1000110001000000000000001000 q
b10 '
b10 Q
b10 m
b10 s
b10100 +
b10100 f
b10001100010000000000000010 p
b10 X
b10 P
b10001 K
b10001 J
b10001 _
b10100 ,
b10100 d
b10100 e
b100010001100010000000000000010 :
b100010001100010000000000000010 I
b10100 .
b10100 R
b10100 c
b1100 1
b1100 T
b1100 V
b1100 b
b1100 k
b1000 4
b1000 H
b1000 U
b1000 l
1!
#5
0!
#6
b10000000010000000 (
b10000000010000000 S
b10000000010000000 n
b0 <
b0 j
b0 0
b0 C
b0 Z
b0 i
b0 -
b0 @
b0 u
b100000000010000000010000000 8
b100000000010000000010000000 g
b100000000010000000010000000 q
b100000000100000 '
b100000000100000 Q
b100000000100000 m
b100000000100000 s
0>
b0 ?
b0 E
b0 W
13
b10000000010010000 +
b10000000010010000 f
b1000000000100000000100000 p
b100000 X
b100000000100000 P
b0 K
b1000 J
b1000 `
b0 _
b0 D
b10000000010010000 ,
b10000000010010000 d
b10000000010010000 e
b1000000000100000000100000 :
b1000000000100000000100000 I
b10000000010010000 .
b10000000010010000 R
b10000000010010000 c
b10000 1
b10000 T
b10000 V
b10000 b
b10000 k
b1100 4
b1100 H
b1100 U
b1100 l
1!
#7
0!
#8
1$
1%
b0 (
b0 S
b0 n
b110 /
b110 B
b110 Y
b100000000000000000000000000 8
b100000000000000000000000000 g
b100000000000000000000000000 q
b0 '
b0 Q
b0 m
b0 s
1>
b101 ?
b101 E
b101 W
1=
03
b10100 +
b10100 f
b1000000000000000000000000 p
b0 X
b0 P
b0 `
b100 D
b10100 ,
b10100 d
b10100 e
b10001000000000000000000000000 :
b10001000000000000000000000000 I
b10100 .
b10100 R
b10100 c
b10100 1
b10100 T
b10100 V
b10100 b
b10100 k
b0 <
b0 j
b0 0
b0 C
b0 Z
b0 i
b0 -
b0 @
b0 u
b10 )
b10 O
b10 ]
b10 t
b10000 4
b10000 H
b10000 U
b10000 l
1!
#9
0!
#10
b10000 (
b10000 S
b10000 n
b111 /
b111 B
b111 Y
1$
1%
b100 -
b100 @
b100 u
b100000000000000000000010000 8
b100000000000000000000010000 g
b100000000000000000000010000 q
b100 '
b100 Q
b100 m
b100 s
b111 ?
b111 E
b111 W
b11000 +
b11000 f
b1000000000000000000000100 p
b100 X
b100 P
b101 D
b11000 ,
b11000 d
b11000 e
b10101000000000000000000000100 :
b10101000000000000000000000100 I
b101000 .
b101000 R
b101000 c
b11000 1
b11000 T
b11000 V
b11000 b
b11000 k
b10100 4
b10100 H
b10100 U
b10100 l
1!
#11
0!
#12
b100 (
b100 S
b100 n
b1 -
b1 @
b1 u
b1000010000000000000000000100 8
b1000010000000000000000000100 g
b1000010000000000000000000100 q
b1 '
b1 Q
b1 m
b1 s
b11100 +
b11100 f
b10000100000000000000000001 p
b1 X
b1 P
b10000 K
b10000 J
b10000 _
b111111 D
b11100 ,
b11100 d
b11100 e
b11111110000100000000000000000001 :
b11111110000100000000000000000001 I
b100000 .
b100000 R
b100000 c
b11100 1
b11100 T
b11100 V
b11100 b
b11100 k
b11000 4
b11000 H
b11000 U
b11000 l
1!
#13
0!
#14
b11111111111111100000000010001000 (
b11111111111111100000000010001000 S
b11111111111111100000000010001000 n
b1 /
b1 B
b1 Y
0%
b0 -
b0 @
b0 u
0$
b1000010001100000000010001000 8
b1000010001100000000010001000 g
b1000010001100000000010001000 q
b11111111111111111000000000100010 '
b11111111111111111000000000100010 Q
b11111111111111111000000000100010 m
b11111111111111111000000000100010 s
b10001 &
b10001 M
b10001 a
0>
b0 ?
b0 E
b0 W
0=
13
b11111111111111100000000010101000 +
b11111111111111100000000010101000 f
b10000100011000000000100010 p
b100010 X
b1000000000100010 P
b10001 K
b10000 `
b10001 _
b0 D
b11111111111111100000000010101000 ,
b11111111111111100000000010101000 d
b11111111111111100000000010101000 e
b10000100011000000000100010 :
b10000100011000000000100010 I
b11111111111111100000000010101000 .
b11111111111111100000000010101000 R
b11111111111111100000000010101000 c
b100000 1
b100000 T
b100000 V
b100000 b
b100000 k
b0 )
b0 O
b0 ]
b0 t
b11100 4
b11100 H
b11100 U
b11100 l
1!
#15
0!
#16
bx00 (
bx00 S
bx00 n
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 8
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 g
b0xxxxxxxxxxxxxxxxxxxxxxxxxx00 q
bx '
bx Q
bx m
bx s
bx &
bx M
bx a
bx +
bx f
bx p
bx X
bx P
bx K
bx J
bx `
bx _
bx D
bx ,
bx d
bx e
bx :
bx I
bx .
bx R
bx c
b100100 1
b100100 T
b100100 V
b100100 b
b100100 k
b100000 4
b100000 H
b100000 U
b100000 l
1!
#17
0!
