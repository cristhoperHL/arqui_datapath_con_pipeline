$date
	Mon Nov 11 02:02:25 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ALU $end
$var wire 4 ! alu_ctrl [3:0] $end
$var wire 32 " entr1 [31:0] $end
$var wire 32 # entr2 [31:0] $end
$var reg 32 $ alu_result [31:0] $end
$var reg 1 % zero $end
$upscope $end
$scope module ALU_Control $end
$var wire 2 & aluOp [1:0] $end
$var wire 6 ' func [5:0] $end
$var reg 4 ( out [3:0] $end
$upscope $end
$scope module Adder $end
$var wire 32 ) a [31:0] $end
$var wire 32 * b [31:0] $end
$var wire 32 + y [31:0] $end
$upscope $end
$scope module And $end
$var wire 1 , a $end
$var wire 1 - b $end
$var wire 1 . out $end
$upscope $end
$scope module Control $end
$var wire 6 / Instruction [5:0] $end
$var wire 1 0 clk $end
$var reg 2 1 ALUOp [1:0] $end
$var reg 1 2 ALUSrc $end
$var reg 1 3 Branch $end
$var reg 1 4 Jump $end
$var reg 2 5 MemRead [1:0] $end
$var reg 2 6 MemWrite [1:0] $end
$var reg 1 7 MemtoReg $end
$var reg 1 8 RegDst $end
$var reg 1 9 RegWrite $end
$upscope $end
$scope module Data_Memory $end
$var wire 32 : address [31:0] $end
$var wire 1 ; clk $end
$var wire 2 < memread [1:0] $end
$var wire 2 = memwrite [1:0] $end
$var wire 32 > writedata [31:0] $end
$var reg 32 ? read_data [31:0] $end
$upscope $end
$scope module InstructionMemory $end
$var wire 1 @ clk $end
$var wire 32 A pc [31:0] $end
$var reg 32 B out [31:0] $end
$upscope $end
$scope module Register_File $end
$var wire 1 C clk $end
$var wire 5 D readreg1 [4:0] $end
$var wire 5 E readreg2 [4:0] $end
$var wire 1 F regwrite $end
$var wire 32 G writedata [31:0] $end
$var wire 5 H writereg [4:0] $end
$var reg 32 I read_data1 [31:0] $end
$var reg 32 J read_data2 [31:0] $end
$upscope $end
$scope module Shift_Left_Branch $end
$var wire 32 K imm [31:0] $end
$var reg 32 L branch_address [31:0] $end
$upscope $end
$scope module Shift_Left_Jump $end
$var wire 4 M PC [3:0] $end
$var wire 26 N imm [25:0] $end
$var reg 32 O jump [31:0] $end
$var reg 2 P shift [1:0] $end
$upscope $end
$scope module SignExtend $end
$var wire 16 Q a [15:0] $end
$var reg 32 R b [31:0] $end
$upscope $end
$scope module adder_pc $end
$var wire 32 S pc [31:0] $end
$var reg 32 T pc_add [31:0] $end
$upscope $end
$scope module mux2_1 $end
$var wire 32 U a [31:0] $end
$var wire 32 V b [31:0] $end
$var wire 1 W sel $end
$var wire 32 X out [31:0] $end
$upscope $end
$scope module mux2_1_5 $end
$var wire 5 Y a [4:0] $end
$var wire 5 Z b [4:0] $end
$var wire 1 [ sel $end
$var wire 5 \ out [4:0] $end
$upscope $end
$scope module testbench $end
$var reg 1 ] clk $end
$var reg 1 ^ reset $end
$scope module test $end
$var wire 32 _ address_final [31:0] $end
$var wire 1 ] clk $end
$var wire 1 ^ reset $end
$var wire 32 ` Out_PC [31:0] $end
$scope module call_pc $end
$var wire 1 ] clk $end
$var wire 32 a d [31:0] $end
$var wire 1 ^ reset $end
$var reg 32 b q [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 b
bz a
b0 `
bz _
1^
1]
bz \
z[
bz Z
bz Y
bz X
zW
bz V
bz U
bx T
bz S
bz R
bz Q
b0 P
bz00 O
bz N
bz M
bz00 L
bz K
bx J
bx I
bz H
bz G
zF
bz E
bz D
zC
bx B
bz A
z@
bx ?
bz >
bz =
bz <
z;
bz :
x9
x8
x7
bx 6
bx 5
x4
x3
x2
bx 1
z0
bz /
x.
z-
z,
bx +
bz *
bz )
bx (
bz '
bz &
0%
bx $
bz #
bz "
bz !
$end
#1
0^
0]
#2
bz `
bz b
1]
#3
0]
#4
1]
#5
0]
#6
1]
#7
0]
#8
1]
#9
0]
#10
1]
#11
0]
#12
1]
#13
0]
#14
1]
#15
0]
#16
1]
#17
0]
#18
1]
#19
0]
#20
1]
#21
0]
#22
1]
#23
0]
#24
1]
#25
0]
#26
1]
#27
0]
#28
1]
#29
0]
#30
1]
#31
0]
#32
1]
