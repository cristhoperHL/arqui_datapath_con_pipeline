$date
	Mon Nov 11 20:19:17 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ALU $end
$var wire 4 ! alu_ctrl [3:0] $end
$var wire 32 " entr1 [31:0] $end
$var wire 32 # entr2 [31:0] $end
$var reg 32 $ alu_result [31:0] $end
$var reg 1 % zero $end
$upscope $end
$scope module ALU_Control $end
$var wire 2 & aluOp [1:0] $end
$var wire 6 ' func [5:0] $end
$var reg 4 ( out [3:0] $end
$upscope $end
$scope module Adder $end
$var wire 32 ) a [31:0] $end
$var wire 32 * b [31:0] $end
$var wire 32 + y [31:0] $end
$upscope $end
$scope module And $end
$var wire 1 , a $end
$var wire 1 - b $end
$var wire 1 . out $end
$upscope $end
$scope module Data_Memory $end
$var wire 32 / address [31:0] $end
$var wire 1 0 clk $end
$var wire 2 1 memread [1:0] $end
$var wire 2 2 memwrite [1:0] $end
$var wire 32 3 writedata [31:0] $end
$var reg 32 4 read_data [31:0] $end
$upscope $end
$scope module Register_File $end
$var wire 1 5 clk $end
$var wire 5 6 readreg1 [4:0] $end
$var wire 5 7 readreg2 [4:0] $end
$var wire 1 8 regwrite $end
$var wire 32 9 writedata [31:0] $end
$var wire 5 : writereg [4:0] $end
$var reg 32 ; read_data1 [31:0] $end
$var reg 32 < read_data2 [31:0] $end
$upscope $end
$scope module Shift_Left_Branch $end
$var wire 32 = imm [31:0] $end
$var reg 32 > branch_address [31:0] $end
$upscope $end
$scope module Shift_Left_Jump $end
$var wire 4 ? PC [3:0] $end
$var wire 26 @ imm [25:0] $end
$var reg 32 A jump [31:0] $end
$var reg 2 B shift [1:0] $end
$upscope $end
$scope module SignExtend $end
$var wire 16 C a [15:0] $end
$var reg 32 D b [31:0] $end
$upscope $end
$scope module mux2_1 $end
$var wire 32 E a [31:0] $end
$var wire 32 F b [31:0] $end
$var wire 1 G sel $end
$var wire 32 H out [31:0] $end
$upscope $end
$scope module mux2_1_5 $end
$var wire 5 I a [4:0] $end
$var wire 5 J b [4:0] $end
$var wire 1 K sel $end
$var wire 5 L out [4:0] $end
$upscope $end
$scope module testbench $end
$var reg 1 M clk $end
$var reg 1 N reset $end
$scope module test $end
$var wire 1 M clk $end
$var wire 1 N reset $end
$var wire 32 O address_final [31:0] $end
$var wire 1 P RegWrite $end
$var wire 1 Q RegDst $end
$var wire 32 R Out_PC [31:0] $end
$var wire 1 S MemtoReg $end
$var wire 2 T MemWrite [1:0] $end
$var wire 2 U MemRead [1:0] $end
$var wire 1 V Jump $end
$var wire 32 W Instruction [31:0] $end
$var wire 1 X Branch $end
$var wire 1 Y ALUsrc $end
$var wire 2 Z ALUOP [1:0] $end
$scope module call_Control $end
$var wire 6 [ Instruction [5:0] $end
$var wire 1 M clk $end
$var reg 2 \ ALUOp [1:0] $end
$var reg 1 Y ALUSrc $end
$var reg 1 X Branch $end
$var reg 1 V Jump $end
$var reg 2 ] MemRead [1:0] $end
$var reg 2 ^ MemWrite [1:0] $end
$var reg 1 S MemtoReg $end
$var reg 1 Q RegDst $end
$var reg 1 P RegWrite $end
$upscope $end
$scope module call_IM $end
$var wire 32 _ pc [31:0] $end
$var reg 32 ` out [31:0] $end
$var integer 32 a i [31:0] $end
$upscope $end
$scope module call_adder_pc $end
$var wire 32 b pc [31:0] $end
$var reg 32 c pc_add [31:0] $end
$upscope $end
$scope module call_pc $end
$var wire 1 M clk $end
$var wire 32 d d [31:0] $end
$var wire 1 N reset $end
$var reg 32 e q [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 e
b1 d
b1 c
b0 b
b1000 a
b10001100101000000000100000 `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b0 Z
0Y
0X
b10001100101000000000100000 W
0V
b0 U
b0 T
0S
b0 R
1Q
1P
b1 O
1N
1M
bz L
zK
bz J
bz I
bz H
zG
bz F
bz E
bz D
bz C
b0 B
bz00 A
bz @
bz ?
bz00 >
bz =
bx <
bx ;
bz :
bz 9
z8
bz 7
bz 6
z5
bx 4
bz 3
bz 2
bz 1
z0
bz /
x.
z-
z,
bx +
bz *
bz )
bx (
bz '
bz &
0%
bx $
bz #
bz "
bz !
$end
#1
0N
0M
#2
b10100101010100000000100010 W
b10100101010100000000100010 `
b10 O
b10 c
b10 d
b1 R
b1 _
b1 b
b1 e
1M
#3
0M
#4
b1010010110100100000100100 W
b1010010110100100000100100 `
b11 O
b11 c
b11 d
b10 R
b10 _
b10 b
b10 e
1M
#5
0M
#6
b10001100101000000000100101 W
b10001100101000000000100101 `
b100 O
b100 c
b100 d
b11 R
b11 _
b11 b
b11 e
1M
#7
0M
#8
b10110101111010100000100111 W
b10110101111010100000100111 `
b101 O
b101 c
b101 d
b100 R
b100 _
b100 b
b100 e
1M
#9
0M
#10
b10101101100110000000101010 W
b10101101100110000000101010 `
b110 O
b110 c
b110 d
b101 R
b101 _
b101 b
b101 e
1M
#11
0M
#12
0P
xY
bx Z
bx \
xS
1V
xQ
b1000 [
b100001100011000000000000000101 W
b100001100011000000000000000101 `
b111 O
b111 c
b111 d
b110 R
b110 _
b110 b
b110 e
1M
#13
0M
#14
b1000 O
b1000 c
b1000 d
b111 R
b111 _
b111 b
b111 e
1M
#15
0M
#16
bx [
bx W
bx `
b1001 O
b1001 c
b1001 d
b1000 R
b1000 _
b1000 b
b1000 e
1M
#17
0M
#18
b1010 O
b1010 c
b1010 d
b1001 R
b1001 _
b1001 b
b1001 e
1M
#19
0M
#20
b1011 O
b1011 c
b1011 d
b1010 R
b1010 _
b1010 b
b1010 e
1M
